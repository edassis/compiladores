/* This block of code will go into the header file generated by bison */
%code requires{}

/* This block will be put into the cpp source code */
%{
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include "lexer.hpp"
#include "globals.h"
%}

%union{
   double dval;
   int ival;
   char* text;
}

%define parse.error verbose
%locations

%start program

%token MUL DIV PLUS MINUS 
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token AND OR NOT
%token LER ESCREVER
%token IF ELSE RET FOR WHILE
%token INT FLOAT VOID
%token LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE SEMI COMMA
%token <text> ID
%token <dval> NUM
%token <text> STRCON

%type <dval> expr   /* Problemas com comparações lógicas? */

%% 
program: stmt_list                            {}
         ;

stmt_list:  %empty
            | stmt_list stmt
            ;

    /* decl_list:  %empty */
    /*             | decl_list decl */
    /*             ; */

decl_stmt:  decl SEMI
            ;

decl:       var_decl
            ;

var_decl:   type_spec ID                    { printf("Declaracao de variavel %s\n", $2); }
            ;

local_decl: %empty 
            | local_decl decl
            ;

stmt:   decl_stmt                               {}
        | assign_stmt                           {}
        | func_stmt                             {}
        | selection_stmt                        {}
        | iteration_stmt                        {}
        | return_stmt                           {}
        /* | compound_stmt                         {} */
        ;

     /* Permitir escopo */ 
    /* compound_stmt:  LBRACE local_decl stmt_list RBRACE */
    /*                 ; */


func_stmt:   write_func SEMI
            | read_func SEMI
            /* Funções reais desativadas */
            /* | type_spec ID LPAREN parm_list RPAREN compound_stmt */
            ; 

write_func: ESCREVER LPAREN expr RPAREN     { printf("\t%f\n", $3); }
            ;

read_func:  LER LPAREN RPAREN               {}
            | LER LPAREN VOID RPAREN        {}
            ;

assign_stmt:    assign SEMI         {printf("atribuicao stmt\n");}
                ;

assign: ID ASSIGN expr              {printf("atribuicao 1\n");}
        | var_decl ASSIGN expr      {printf("atribuicao 2\n");}
        ;


    /* params: %empty */
    /*         | param_list */
    /*         ; */

    /* param_list:  var_decl                        {} */
    /*             | parm_list COMMA var_decl       {}  */
    /*             ; */


selection_stmt: IF LPAREN expr RPAREN LBRACE stmt_list RBRACE                                       {printf("if\n");}
                | IF LPAREN expr RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE        {printf("if/else\n");}  /* Sequencia de if/else if */
                ;


iteration_stmt: WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE                                    {printf("while\n");}
                | FOR LPAREN assign SEMI expr SEMI assign RPAREN LBRACE stmt_list RBRACE            {printf("for\n");}
                ;


return_stmt:    RET SEMI                    {printf("return\n");}
                | RET expr SEMI             {printf("return value\n");}
                ;


expr:   logical_expr relop logical_expr       {printf("logical_expr RELOP logical_expr\n");}
        /* | expr binop expr           {printf("expr binop exprn\n");} */
        /* | expr logical_op expr      {printf("expr logical_op expr\n");} */
        /* | expr relop expr           {printf("expr relop expr\n");} */
        | logical_expr                        {printf("logical_expr\n");}
        ;

logical_expr:   logical_expr AND unary_expr     {printf("logical_exp AND unary_expr\n");}
                | logical_expr OR unary_expr    {printf("logical_exp OR unary_expr\n");}
                | unary_expr                    {printf("unary_expr\n");}
                ;

unary_expr: NOT simple_expr                     {printf("NOT simple_expr\n");}
            | simple_expr                       {printf("simple_expr\n");}
            ;

simple_expr:    simple_expr PLUS term           {printf("simple_expr PLUS term\n");}
                | simple_expr MINUS term        {printf("simple_expr MINUS term\n");}
                | term                          {printf("term\n");}
                ;

term:   term MUL factor                         {printf("term MUL factor\n");}
        | term DIV factor                       {printf("term DIV factor\n");}
        | factor                                {printf("factor\n");}
        ;

factor: LPAREN expr RPAREN                      {printf("(expr)\n");}
        | NUM                                   {printf("num\n");}
        | ID                                    {printf("id\n");}
        ;

relop:  EQ                          
        | NEQ
        | LT
        | LTE
        | GT
        | GTE
        ;

    /* logical_op: AND */
    /*             | OR */
    /*             ; */

    /* binop:  PLUS */
    /*         | MINUS */
    /*         | MUL */
    /*         | DIV */
    /*         ; */

type_spec:  INT
            | FLOAT
            | VOID
            ;

%%

int lineno = 0;

int main(int argc, char **argv) {
   if (argc > 1) {
      yyin = fopen(argv[1], "r");
      if (yyin == NULL){
         printf("syntax: %s filename\n", argv[0]);
      }
   }

   yyparse(); // Calls yylex() for tokens.
   
   return 0;
}

void yyerror(const char *msg) {
   printf("** Line %d: %s\n", lineno, msg);
}
