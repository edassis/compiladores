/* This block of code will go into the header file generated by bison */
%code requires{
   class Data;
}

/* This block will be put into the cpp source code */
%{
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include "lexer.hpp"
#include "globals.h"

class Data {
public:
   int data;
   Data() { data = 0; }
   ~Data() {}
};

%}

%union{
   double dval;
   int ival;
   char* text;
   Data* cval;
}

%define parse.error verbose
%locations

%start program

%token MUL DIV PLUS MINUS 
%token ASSIGN
%token EQ NEQ LT LTE GT GTE
%token AND OR NOT
%token LER ESCREVER
%token IF ELSE RET FOR WHILE
%token INT FLOAT VOID
%token LPAREN RPAREN LBRACK RBRACK LBRACE RBRACE SEMI COMMA
%token <text> ID
%token <dval> NUM

%type <cval> program
 /* %type <ival> exp */
%type <dval> simple_exp term

%left PLUS MINUS MUL DIV

%% 
program: stmt_seq                    { $$ = new Data(); }
         ;

stmt_seq: stmt                                          {} 
          | stmt_seq SEMI stmt                          {}
          | stmt_seq LBRACE stmt_seq RBRACE stmt        {}
		  ;

stmt: decl_stmt                             {} 
      | assign_stmt                         {}
      | func_stmt                           {}
      | if_stmt                             {}
      | else_stmt                           {}
      | for_stmt                            {}
      | while_stmt                          {}
      ;

assign_stmt: ID ASSIGN simple_exp               { printf("\t%s = %f\n", $1, $3); }
             | decl_stmt ASSIGN simple_exp      { printf("\t%f\n", $3); }
             ;

decl_stmt: INT ID                           { printf("\t%s\n", $2); }
           | FLOAT ID                       { printf("\t%s\n", $2); }
           ;

func_stmt: write_func                       {}
           | read_func                      {}
           | ID LPAREN param_args RPAREN {}
           ;

param_args: /* void */                      {}
            | decl_stmt                     {}
            | param_args COMMA decl_stmt    {} 
            ;

write_func: ESCREVER LPAREN simple_exp RPAREN    { printf("\t%f\n", $3); }
            ;

read_func:  LER LPAREN RPAREN                   {}
            | LER LPAREN VOID RPAREN            {}
            ;


if_stmt:    IF LPAREN logical_comp RPAREN       {}
            ;

else_stmt:  ELSE                                {}
            ;

while_stmt: WHILE LPAREN logical_comp RPAREN    {}
            ;

for_stmt:   FOR LPAREN decl_stmt SEMI logical_comp SEMI assign_stmt RPAREN {}
            ;


simple_exp: term                                { $$ = $1; }
            | simple_exp PLUS simple_exp        { $$ = $1 + $3; }
            | simple_exp MINUS simple_exp       { $$ = $1 - $3; }
            ;

term: NUM
      | MINUS term                  { $$ = -$2; }
      | term MUL term               { $$ = $1 * $3; }
      | term DIV term               { if ($3==0) yyerror("divide by zero"); else $$ = $1 / $3; }
      ;
            
logical_comp: values_comp


values_comp:    ID                  {}
                | NUM               {}
                ;

relop: 
%%

int lineno = 0;

int main(int argc, char **argv) {
   if (argc > 1) {
      yyin = fopen(argv[1], "r");
      if (yyin == NULL){
         printf("syntax: %s filename\n", argv[0]);
      }
   }

   yyparse(); // Calls yylex() for tokens.
   
   return 0;
}

void yyerror(const char *msg) {
   printf("** Line %d: %s\n", lineno, msg);
}
